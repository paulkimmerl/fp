<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Shader mit OrbitControls</title>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; background: black; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.1/examples/js/controls/OrbitControls.min.js"></script>

<script id="fragShader" type="x-shader/x-fragment">
uniform float time;
uniform vec2 resolution;
uniform vec3 lights[12];

mat3 rotY(float a) {
  float s = sin(a), c = cos(a);
  return mat3(c,0.0,-s, 0.0,1.0,0.0, s,0.0,c);
}

mat3 rotZ(float a) {
  float s = sin(a), c = cos(a);
  return mat3(c,s,0.0, -s,c,0.0, 0.0,0.0,1.0);
}

float sdf(vec3 p, float t) {
  p = rotY(t * 0.2) * p;
  p = rotZ(t * 0.15) * p;
  for (int i = 0; i < 3; i++) {
    p = abs(p) - 0.5 + 0.2 * sin(t * 0.05 + float(i));
    p = rotY(t * 0.05 + float(i)) * p;
    p = rotZ(t * 0.03 + float(i)) * p;
  }
  return length(p) - 0.5;
}

vec3 getNormal(vec3 p, float t) {
  float e = 0.001;
  vec2 h = vec2(e,0);
  return normalize(vec3(
    sdf(p + h.xyy, t) - sdf(p - h.xyy, t),
    sdf(p + h.yxy, t) - sdf(p - h.yxy, t),
    sdf(p + h.yyx, t) - sdf(p - h.yyx, t)
  ));
}

void main() {
  vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;
  uv.x *= resolution.x / resolution.y;

  vec3 ro = vec3(2.5, 1.5, 3.0);
  vec3 ta = vec3(0.0);
  vec3 f = normalize(ta - ro);
  vec3 r = normalize(cross(vec3(0,1,0), f));
  vec3 u = cross(f, r);
  vec3 rd = normalize(uv.x * r + uv.y * u + f);

  float t = 0.0;
  bool hit = false;
  vec3 p;
  for (int i = 0; i < 100; i++) {
    p = ro + rd * t;
    float d = sdf(p, time);
    if (d < 0.002) { hit = true; break; }
    if (t > 20.0) break;
    t += d;
  }

  vec3 col = vec3(0.0);
  if (hit) {
    vec3 n = getNormal(p, time);
    for (int i = 0; i < 12; i++) {
      vec3 L = normalize(lights[i] - p);
      float diff = max(dot(n, L), 0.0);
      float dist = length(lights[i] - p);
      float atten = 0.3 / (dist * dist + 0.1);
      col += (vec3(0.6,0.8,1.0) * diff + vec3(1.0) * pow(max(dot(reflect(-L, n), -rd), 0.0), 8.0)) * atten;
    }
    col = pow(col, vec3(0.45));
  }

  gl_FragColor = vec4(col, 1.0);
}
</script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(2.5, 1.5, 3.0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// OrbitControls mit Auto-Rotate
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.1;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;
controls.zoomSpeed = 0.8;
controls.enablePan = false;

// Plane + ShaderMaterial
const geometry = new THREE.PlaneBufferGeometry(2, 2);
const uniforms = {
  time: { value: 0 },
  resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
  lights: { value: new Array(12).fill().map(() => new THREE.Vector3()) }
};

const material = new THREE.ShaderMaterial({
  fragmentShader: document.getElementById("fragShader").textContent,
  uniforms: uniforms
});
const quad = new THREE.Mesh(geometry, material);
scene.add(quad);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
});

// ZufÃ¤llige Lichtbewegungen
const lightOffsets = Array.from({length: 12}, () =>
  [Math.random()*10, Math.random()*10, Math.random()*10]
);

function updateLights(t) {
  for (let i = 0; i < 12; i++) {
    uniforms.lights.value[i].set(
      Math.sin(t * 0.8 + lightOffsets[i][0]) * 2.0,
      Math.cos(t * 1.1 + lightOffsets[i][1]) * 1.5,
      Math.sin(t * 1.3 + lightOffsets[i][2]) * 2.0
    );
  }
}

// Renderloop
function animate(time) {
  requestAnimationFrame(animate);
  uniforms.time.value = time * 0.001;
  updateLights(uniforms.time.value);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
