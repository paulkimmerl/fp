<!DOCTYPE html><html lang="de">
<head>
<meta charset="UTF-8">
<title>Shader Szene mit Orbit Controls</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  html, body { margin: 0; padding: 0; overflow: hidden; background: black; height: 100%; }
  canvas { width: 100vw; height: 100vh; display: block; cursor: grab; }
  canvas:active { cursor: grabbing; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script type="x-shader/x-vertex" id="vertexShader">
attribute vec3 position;
void main() {
  gl_Position = vec4(position, 1.0);
}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
precision highp float;
uniform vec2 resolution;
uniform float time;
uniform vec3 camPos;
uniform vec3 camTarget;mat3 rotationY(float a) { float s = sin(a), c = cos(a); return mat3(c,0.0,-s, 0.0,1.0,0.0, s,0.0,c); } mat3 rotationZ(float a) { float s = sin(a), c = cos(a); return mat3(c,s,0.0, -s,c,0.0, 0.0,0.0,1.0); } float fBox(vec3 p, vec3 b) { vec3 d = abs(p) - b; return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0); } float scene(vec3 p, float time) { float baseSize = 0.3 + 0.1 * sin(time * 0.3); float box = fBox(p, vec3(baseSize)); float sphere = length(p) - (0.4 + 0.1 * sin(time * 0.5)); return min(box, sphere); } vec3 getNormal(vec3 p, float time) { float e = 0.001; vec2 h = vec2(e,0.0); return normalize(vec3( scene(p + h.xyy, time) - scene(p - h.xyy, time), scene(p + h.yxy, time) - scene(p - h.yxy, time), scene(p + h.yyx, time) - scene(p - h.yyx, time) )); } void main() { vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0; uv.x *= resolution.x / resolution.y; vec3 ro = camPos; vec3 ta = camTarget; vec3 f = normalize(ta - ro); vec3 r = normalize(cross(vec3(0.0,1.0,0.0), f)); vec3 u = cross(f, r); vec3 rd = normalize(uv.x * r + uv.y * u + f); float t = 0.0; float d; bool hit = false; for (int i = 0; i < 100; i++) { vec3 p = ro + rd * t; d = scene(p, time); if (d < 0.001) { hit = true; break; } if (t > 20.0) break; t += d; } vec3 col = vec3(0.0); if (hit) { vec3 p = ro + rd * t; vec3 n = getNormal(p, time); vec3 lightDir = normalize(vec3(0.3, 0.5, 0.6)); float diff = clamp(dot(n, lightDir), 0.0, 1.0); float spec = pow(clamp(dot(reflect(-lightDir, n), -rd), 0.0, 1.0), 16.0); col = vec3(0.8,0.9,1.0) * diff + vec3(1.0) * spec * 0.5; col = pow(col, vec3(0.4545)); } gl_FragColor = vec4(col, 1.0); } </script>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener("resize", resize);
resize();
function compileShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    return null;
  }
  return shader;
}
const vs = compileShader(gl.VERTEX_SHADER, document.getElementById("vertexShader").textContent);
const fs = compileShader(gl.FRAGMENT_SHADER, document.getElementById("fragmentShader").textContent);
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
gl.useProgram(program);
const positionLoc = gl.getAttribLocation(program, 'position');
const resolutionLoc = gl.getUniformLocation(program, 'resolution');
const timeLoc = gl.getUniformLocation(program, 'time');
const camPosLoc = gl.getUniformLocation(program, 'camPos');
const camTargetLoc = gl.getUniformLocation(program, 'camTarget');
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1,0, 1,-1,0, -1,1,0,
  -1,1,0, 1,-1,0, 1,1,0
]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);

// Orbit Camera Controls
let theta = Math.PI / 4;
let phi = Math.PI / 4;
let radius = 4;
let target = [0, 0, 0];
function getCamPos() {
  return [
    target[0] + radius * Math.sin(phi) * Math.sin(theta),
    target[1] + radius * Math.cos(phi),
    target[2] + radius * Math.sin(phi) * Math.cos(theta)
  ];
}
let isDragging = false, isPanning = false;
let lastX, lastY;
canvas.addEventListener('mousedown', e => {
  isDragging = true;
  isPanning = e.button === 2 || e.shiftKey;
  lastX = e.clientX;
  lastY = e.clientY;
});
canvas.addEventListener('mouseup', () => isDragging = false);
canvas.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  lastX = e.clientX;
  lastY = e.clientY;
  if (isPanning) {
    target[0] -= dx * 0.01;
    target[1] += dy * 0.01;
  } else {
    theta -= dx * 0.005;
    phi -= dy * 0.005;
    phi = Math.max(0.01, Math.min(Math.PI - 0.01, phi));
  }
});
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  radius += e.deltaY * 0.005;
  radius = Math.max(1, Math.min(20, radius));
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

// Touch Controls
let touchMode = null;
let touchStartDist = 0;
canvas.addEventListener("touchstart", e => {
  if (e.touches.length === 1) {
    touchMode = "rotate";
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  } else if (e.touches.length === 2) {
    touchMode = "zoom";
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    touchStartDist = Math.sqrt(dx * dx + dy * dy);
  }
});
canvas.addEventListener("touchmove", e => {
  e.preventDefault();
  if (touchMode === "rotate" && e.touches.length === 1) {
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
    theta -= dx * 0.005;
    phi -= dy * 0.005;
    phi = Math.max(0.01, Math.min(Math.PI - 0.01, phi));
  } else if (touchMode === "zoom" && e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const delta = dist - touchStartDist;
    radius -= delta * 0.01;
    radius = Math.max(0.5, Math.min(20, radius));
    touchStartDist = dist;
  }
});
canvas.addEventListener("touchend", () => touchMode = null);

// Render Loop
function render(t) {
  const timeSec = t * 0.001;
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  const camPos = getCamPos();
  gl.uniform2f(resolutionLoc, canvas.width, canvas.height);
  gl.uniform1f(timeLoc, timeSec);
  gl.uniform3fv(camPosLoc, camPos);
  gl.uniform3fv(camTargetLoc, target);
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script></body>
</html>
