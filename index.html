<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Shader mit OrbitControls</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      height: 100%;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<!-- Three.js & OrbitControls via CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.min.js"></script>

<script>
  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(3, 2, 5);

  let renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  let controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;

  let uniforms = {
    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    time: { value: 0.0 },
    camPos: { value: new THREE.Vector3() }
  };

  let material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `,
    fragmentShader: `
      precision highp float;
      uniform vec2 resolution;
      uniform float time;
      uniform vec3 camPos;

      mat3 rotationY(float a) {
        float c = cos(a), s = sin(a);
        return mat3(
          c, 0.0, -s,
          0.0, 1.0, 0.0,
          s, 0.0, c
        );
      }

      mat3 rotationZ(float a) {
        float c = cos(a), s = sin(a);
        return mat3(
          c, s, 0.0,
         -s, c, 0.0,
          0.0, 0.0, 1.0
        );
      }

      float fBox(vec3 p, vec3 b) {
        vec3 d = abs(p) - b;
        return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
      }

      float scene(vec3 p) {
        float s = 0.3;
        vec3 pos = p;
        float value = 1.0;

        for (int i = 0; i < 6; i++) {
          vec2 absXY = abs(pos.xy) - value;
          pos = vec3(absXY, pos.z);
          pos = rotationY(time * 0.2) * pos;
          pos = rotationZ(time * 0.15) * pos;
          value *= 0.9;
        }

        float box1 = fBox(pos, vec3(0.3));
        float box2 = fBox(pos, vec3(0.1));
        float d = -box1;
        d = min(d, box2);

        float sphere = length(pos) - 0.4;
        return max(d, sphere);
      }

      vec3 getNormal(vec3 p) {
        float e = 0.001;
        vec2 h = vec2(e, 0.0);
        return normalize(vec3(
          scene(p + h.xyy) - scene(p - h.xyy),
          scene(p + h.yxy) - scene(p - h.yxy),
          scene(p + h.yyx) - scene(p - h.yyx)
        ));
      }

      void main() {
        vec2 uv = (gl_FragCoord.xy / resolution) * 2.0 - 1.0;
        uv.x *= resolution.x / resolution.y;

        vec3 ro = camPos;
        vec3 ta = vec3(0.0);
        vec3 f = normalize(ta - ro);
        vec3 r = normalize(cross(vec3(0.0,1.0,0.0), f));
        vec3 u = cross(f, r);
        vec3 rd = normalize(uv.x * r + uv.y * u + f);

        float t = 0.0;
        float d;
        bool hit = false;
        for(int i = 0; i < 100; i++) {
          vec3 p = ro + rd * t;
          d = scene(p);
          if (d < 0.001) {
            hit = true;
            break;
          }
          if (t > 20.0) break;
          t += d;
        }

        vec3 col = vec3(0.0);
        if (hit) {
          vec3 p = ro + rd * t;
          vec3 n = getNormal(p);
          vec3 lightDir = normalize(vec3(0.7, 1.0, 0.8));
          float diff = clamp(dot(n, lightDir), 0.0, 1.0);
          float spec = pow(clamp(dot(reflect(-lightDir, n), -rd), 0.0, 1.0), 16.0);
          col = vec3(0.8, 0.9, 1.0) * diff + vec3(1.0) * spec * 0.4;
          col = pow(col, vec3(0.4545));
        }

        gl_FragColor = vec4(col, 1.0);
      }
    `
  });

  let plane = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material);
  scene.add(plane);

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
  });

  function animate(t) {
    uniforms.time.value = t * 0.001;
    uniforms.camPos.value.copy(camera.position);
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  animate();
</script>
</body>
</html>
