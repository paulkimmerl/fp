<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Custom Shader mit OrbitControls</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.min.js"></script>
<script>
  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
  camera.position.z = 3;

  let renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Controls
  let controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Licht
  scene.add(new THREE.AmbientLight(0x404040));
  let directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(3, 5, 2);
  scene.add(directionalLight);

  // Shader
  const uniforms = {
    u_time: { value: 0.0 },
    u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
  };

  const fragmentShader = `
    uniform float u_time;
    uniform vec2 u_resolution;

    float box(vec3 p, vec3 b) {
      vec3 q = abs(p) - b;
      return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
    }

    float scene(vec3 p) {
      vec3 offset = vec3(sin(u_time*0.3)*0.5, cos(u_time*0.2)*0.5, 0.0);
      vec3 s1 = p;
      float r = 0.25;

      for(int i = 0; i < 4; i++) {
        s1.xy = abs(s1.xy) - r;
        s1 = s1.zyx;
        r *= 0.75;
      }

      float d1 = box(s1 + offset, vec3(0.3));
      float d2 = box(p - offset, vec3(0.25));
      return min(d1, d2);
    }

    vec3 getNormal(vec3 p) {
      float eps = 0.001;
      return normalize(vec3(
        scene(p + vec3(eps, 0.0, 0.0)) - scene(p - vec3(eps, 0.0, 0.0)),
        scene(p + vec3(0.0, eps, 0.0)) - scene(p - vec3(0.0, eps, 0.0)),
        scene(p + vec3(0.0, 0.0, eps)) - scene(p - vec3(0.0, 0.0, eps))
      ));
    }

    void main() {
      vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
      vec3 ro = vec3(0.0, 0.0, 3.0);
      vec3 rd = normalize(vec3(uv, -1.5));

      float t = 0.0;
      float d;
      for(int i = 0; i < 64; i++) {
        vec3 p = ro + t * rd;
        d = scene(p);
        if(d < 0.001) break;
        t += d;
        if(t > 10.0) break;
      }

      vec3 col = vec3(0.0);
      if(d < 0.01) {
        vec3 p = ro + t * rd;
        vec3 n = getNormal(p);
        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
        float diff = max(dot(n, lightDir), 0.0);
        col = vec3(diff);
      }

      col = pow(col, vec3(0.4545)); // gamma
      gl_FragColor = vec4(col, 1.0);
    }
  `;

  const vertexShader = `
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  `;

  const material = new THREE.ShaderMaterial({
    uniforms: uniforms,
    vertexShader: vertexShader,
    fragmentShader: fragmentShader
  });

  const geometry = new THREE.PlaneGeometry(2, 2);
  const quad = new THREE.Mesh(geometry, material);
  scene.add(quad);

  // Animation
  function animate(time) {
    uniforms.u_time.value = time * 0.001;
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
  });

  animate();
</script>
</body>
</html>
